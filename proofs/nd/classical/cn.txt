
(*/chapter Cardinal numbers *)

(*/section Numerousities *)

num_eq_equi. ⊢ num_eq X Y ↔ ∃f. bij f X Y, def.
num_le_equi. ⊢ num_le X Y ↔ ∃f. inj f X Y, def.
num_lt_equi. ⊢ num_lt X Y ↔ num_le X Y ∧ ¬∃f. sur f X Y, def.

Map_eq. ⊢ Map X Y = {f | map f X Y}, def.

indicator_eq. ⊢ χ A X =
  {t | ∃x. x ∈ X \ A ∧ t = (x, ∅)} ∪
  {t | ∃x. x ∈ A ∧ t = (x, {∅})}, def.

num_eq_intro. ⊢ (∃f. bij f X Y) → num_eq X Y,
  bij_elimr num_eq_equi.

num_le_fold. ⊢ (∃f. inj f X Y) → num_le X Y,
  bij_elimr num_le_equi.

01. 1 ⊢ inj f X Y, hypo.
02. 1 ⊢ ∃f. inj f X Y, ex_intro 1.
03. 1 ⊢ num_le X Y, num_le_fold 2.
num_le_intro. ⊢ inj f X Y → num_le X Y, subj_intro 3.

num_le_unfold. ⊢ num_le X Y → ∃f. inj f X Y,
  bij_eliml num_le_equi.

01. 1 ⊢ num_le X Y, hypo.
02. 2 ⊢ ¬∃f. sur f X Y, hypo.
03. 1, 2 ⊢ num_le X Y ∧ ¬∃f. sur f X Y, conj_intro 1 2.
04. 1, 2 ⊢ num_lt X Y, rsubj_elim num_lt_equi 3.
num_lt_intro. ⊢ num_le X Y → (¬∃f. sur f X Y) → num_lt X Y,
  subj_intro_ii 4.

01. 1 ⊢ num_le X Y, hypo.
02. 2 ⊢ A ⊆ X, hypo.
03. 1 ⊢ ∃f. inj f X Y, num_le_unfold 1.
04. 4 ⊢ inj f X Y, hypo.
05. 2, 4 ⊢ inj (restr f A) A Y, restr_is_inj 4 2.
06. 2, 4 ⊢ num_le A Y, num_le_intro 5.
07. 1, 2 ⊢ num_le A Y, ex_elim 3 6.
num_le_subclass. ⊢ num_le X Y → A ⊆ X →
  num_le A Y, subj_intro_ii 7.

01. 1 ⊢ map f X Y, hypo.
02. 2 ⊢ set X, hypo.
03. 1, 2 ⊢ set f, map_is_set 1 2.
04. 1, 2 ⊢ f ∈ {f | map f X Y}, comp_intro 3 1.
05. 1, 2 ⊢ f ∈ Map X Y, eq_subst_rev Map_eq 4, P t ↔ f ∈ t.
Map_intro. ⊢ map f X Y → set X → f ∈ Map X Y, subj_intro_ii 5.

01. 1 ⊢ f ∈ Map X Y, hypo.
02. 1 ⊢ f ∈ {f | map f X Y}, eq_subst Map_eq 1, P t ↔ f ∈ t.
03. 1 ⊢ map f X Y, comp_elim 2.
Map_elim. ⊢ f ∈ Map X Y → map f X Y, subj_intro 3.

begin
let χ0 = {t | ∃x. x ∈ X \ A ∧ t = (x, ∅)}.
let χ1 = {t | ∃x. x ∈ A ∧ t = (x, {∅})}.
let Y = {∅, {∅}}.
01. ⊢ set ∅, empty_set_is_set.
02. ⊢ set {∅}, set_sg 1.
03. ⊢ ∅ ∈ Y, in21 1.
04. ⊢ {∅} ∈ Y, in22 2.
05. 5 ⊢ x ∈ X \ A, hypo.
06. 6 ⊢ x ∈ A, hypo.
07. 5 ⊢ ∅ ∈ Y, wk 3.
08. 6 ⊢ {∅} ∈ Y, wk 4.
09. ⊢ x ∈ X \ A → ∅ ∈ Y, subj_intro 7.
10. ⊢ x ∈ A → {∅} ∈ Y, subj_intro 8.
11. ⊢ ∀x. x ∈ X \ A → ∅ ∈ Y, uq_intro 9.
12. ⊢ ∀x. x ∈ A → {∅} ∈ Y, uq_intro 10.
13. ⊢ χ0 = χ0, eq_refl.
14. ⊢ χ1 = χ1, eq_refl.
15. ⊢ map χ0 (X \ A) Y, map_from_term 13 11.
16. ⊢ map χ1 A Y, map_from_term 14 12.
17. ⊢ A ∩ (X \ A) = ∅, intersection_rel_compl.
18. ⊢ (X \ A) ∩ A = A ∩ (X \ A), intersection_comm.
19. ⊢ (X \ A) ∩ A = ∅, eq_trans 18 17.
20. ⊢ map (χ0 ∪ χ1) ((X \ A) ∪ A) Y, map_union_eq_rngs 15 16 19.
21. ⊢ map (χ A X) ((X \ A) ∪ A) Y,
  eq_subst_rev indicator_eq 20, P t ↔ map t ((X \ A) ∪ A) Y.
22. 22 ⊢ A ⊆ X, hypo.
23. 22 ⊢ (X \ A) ∪ A = X, diff_union_subclass 22.
24. 22 ⊢ map (χ A X) X Y, eq_subst 23 21, P t ↔ map (χ A X) t Y.
indicator_is_map. ⊢ A ⊆ X → map (χ A X) X {∅, {∅}}, subj_intro 24.
end

01. 1 ⊢ A ⊆ X, hypo.
02. 2 ⊢ x ∈ X \ A, hypo.
03. ⊢ (x, ∅) = (x, ∅), eq_refl.
04. 2 ⊢ x ∈ X \ A ∧ (x, ∅) = (x, ∅), conj_intro 2 3.
05. 2 ⊢ ∃u. u ∈ X \ A ∧ (x, ∅) = (u, ∅), ex_intro 4.
06. 2 ⊢ set x, set_intro 2.
07. ⊢ set ∅, empty_set_is_set.
08. 2 ⊢ set (x, ∅), set_pair 6 7.
09. 2 ⊢ (x, ∅) ∈ {t | ∃x. x ∈ X \ A ∧ t = (x, ∅)},
  comp_intro 8 5, P t ↔ (∃x. x ∈ X \ A ∧ t = (x, ∅)).
10. 2 ⊢ (x, ∅) ∈ {t | ∃x. x ∈ X \ A ∧ t = (x, ∅)} ∪
  {t | ∃x. x ∈ A ∧ t = (x, {∅})}, union_introl 9.
11. 2 ⊢ (x, ∅) ∈ χ A X, eq_subst_rev indicator_eq 10,
  P u ↔ (x, ∅) ∈ u.
12. 1 ⊢ map (χ A X) X {∅, {∅}}, indicator_is_map 1.
13. 1, 2 ⊢ ∅ = app (χ A X) x, map_app_intro 12 11.
14. 1, 2 ⊢ app (χ A X) x = ∅, eq_symm 13.
indicator_app_is_zero. ⊢ A ⊆ X → x ∈ X \ A → app (χ A X) x = ∅,
  subj_intro_ii 14.

01. 1 ⊢ A ⊆ X, hypo.
02. 2 ⊢ x ∈ A, hypo.
03. ⊢ (x, {∅}) = (x, {∅}), eq_refl.
04. 2 ⊢ x ∈ A ∧ (x, {∅}) = (x, {∅}), conj_intro 2 3.
05. 2 ⊢ ∃u. u ∈ A ∧ (x, {∅}) = (u, {∅}), ex_intro 4.
06. 2 ⊢ set x, set_intro 2.
07. ⊢ set {∅}, set_sg empty_set_is_set.
08. 2 ⊢ set (x, {∅}), set_pair 6 7.
09. 2 ⊢ (x, {∅}) ∈ {t | ∃x. x ∈ A ∧ t = (x, {∅})},
  comp_intro 8 5, P t ↔ (∃x. x ∈ A ∧ t = (x, {∅})).
10. 2 ⊢ (x, {∅}) ∈ {t | ∃x. x ∈ X \ A ∧ t = (x, ∅)} ∪
  {t | ∃x. x ∈ A ∧ t = (x, {∅})}, union_intror 9.
11. 2 ⊢ (x, {∅}) ∈ χ A X, eq_subst_rev indicator_eq 10,
  P u ↔ (x, {∅}) ∈ u.
12. 1 ⊢ map (χ A X) X {∅, {∅}}, indicator_is_map 1.
13. 1, 2 ⊢ {∅} = app (χ A X) x, map_app_intro 12 11.
14. 1, 2 ⊢ app (χ A X) x = {∅}, eq_symm 13.
indicator_app_is_one. ⊢ A ⊆ X → x ∈ A → app (χ A X) x = {∅},
  subj_intro_ii 14.

01. 1 ⊢ A ⊆ X, hypo.
02. 2 ⊢ x ∈ X, hypo.
03. 3 ⊢ app (χ A X) x = {∅}, hypo.
04. 3 ⊢ {∅} = app (χ A X) x, eq_symm 3.
05. 1 ⊢ map (χ A X) X {∅, {∅}}, indicator_is_map 1.
06. 1, 2, 3 ⊢ (x, {∅}) ∈ χ A X, map_app_elim 5 2 4.
07. 1, 2, 3 ⊢ (x, {∅}) ∈ {t | ∃x. x ∈ X \ A ∧ t = (x, ∅)} ∪
  {t | ∃x. x ∈ A ∧ t = (x, {∅})},
  eq_subst indicator_eq 6, P u ↔ (x, {∅}) ∈ u.
08. 1, 2, 3 ⊢
  (x, {∅}) ∈ {t | ∃x. x ∈ X \ A ∧ t = (x, ∅)} ∨
  (x, {∅}) ∈ {t | ∃x. x ∈ A ∧ t = (x, {∅})}, union_elim 7.
09. 9 ⊢ (x, {∅}) ∈ {t | ∃x. x ∈ X \ A ∧ t = (x, ∅)}, hypo.
10. 9 ⊢ ∃u. u ∈ X \ A ∧ (x, {∅}) = (u, ∅), comp_elim 9.
11. 11 ⊢ u ∈ X \ A ∧ (x, {∅}) = (u, ∅), hypo.
12. 11 ⊢ (x, {∅}) = (u, ∅), conj_elimr 11.
13. 2 ⊢ set x, set_intro 2.
14. ⊢ set {∅}, set_sg empty_set_is_set.
15. 2, 11 ⊢ x = u ∧ {∅} = ∅, pair_property 13 14 12.
16. 2, 11 ⊢ {∅} = ∅, conj_elimr 15.
17. 2, 11 ⊢ ∅ = {∅}, eq_symm 16.
18. 2, 11 ⊢ ⊥, neg_elim zero_neq_one 17.
19. 2, 11 ⊢ x ∈ A, efq 18.
20. 2, 9 ⊢ x ∈ A, ex_elim 10 19.
21. 21 ⊢ (x, {∅}) ∈ {t | ∃x. x ∈ A ∧ t = (x, {∅})}, hypo.
22. 21 ⊢ ∃u. u ∈ A ∧ (x, {∅}) = (u, {∅}), comp_elim 21.
23. 23 ⊢ u ∈ A ∧ (x, {∅}) = (u, {∅}), hypo.
24. 23 ⊢ u ∈ A, conj_eliml 23.
25. 23 ⊢ (x, {∅}) = (u, {∅}), conj_elimr 23.
26. 2, 23 ⊢ x = u ∧ {∅} = {∅}, pair_property 13 14 25.
27. 2, 23 ⊢ x = u, conj_eliml 26.
28. 2, 23 ⊢ x ∈ A, eq_subst_rev 27 24.
29. 2, 21 ⊢ x ∈ A, ex_elim 22 28.
30. 1, 2, 3 ⊢ x ∈ A, disj_elim 8 20 29.
from_indicator_app_is_one. ⊢ A ⊆ X → x ∈ X →
  app (χ A X) x = {∅} → x ∈ A, subj_intro_iii 30.

begin
let φ = {t | ∃A. A ∈ power X ∧ t = (A, χ A X)}.
01. 1 ⊢ set X, hypo.
02. 2 ⊢ A ∈ power X, hypo.
03. 2 ⊢ A ⊆ X, power_elim 2.
04. 2 ⊢ map (χ A X) X {∅, {∅}}, indicator_is_map 3.
05. 1, 2 ⊢ χ A X ∈ Map X {∅, {∅}}, Map_intro 4 1.
06. 1 ⊢ A ∈ power X → χ A X ∈ Map X {∅, {∅}}, subj_intro 5.
07. 1 ⊢ ∀A. A ∈ power X → χ A X ∈ Map X {∅, {∅}}, uq_intro 6.
08. ⊢ φ = φ, eq_refl.
09. 1 ⊢ map φ (power X) (Map X {∅, {∅}}), map_from_term 8 7.

10. 10 ⊢ A ∈ power X, hypo.
11. 11 ⊢ B ∈ power X, hypo.
12. 12 ⊢ app φ A = app φ B, hypo.
13. 1, 10 ⊢ app φ A = χ A X, map_from_term_app 8 7 10.
14. 1, 11 ⊢ app φ B = χ B X, map_from_term_app 8 7 11.
15. 1, 10, 12 ⊢ χ A X = app φ B, eq_trans_ll 13 12.
16. 1, 10, 11, 12 ⊢ χ A X = χ B X, eq_trans 15 14.
17. 10 ⊢ A ⊆ X, power_elim 10.
18. 11 ⊢ B ⊆ X, power_elim 11.
19. 19 ⊢ x ∈ A, hypo.
20. 10, 19 ⊢ app (χ A X) x = {∅}, indicator_app_is_one 17 19.
21. 1, 10, 11, 12, 19 ⊢ app (χ B X) x = {∅},
  eq_subst 16 20, P t ↔ app t x = {∅}.
22. 10, 19 ⊢ x ∈ X, incl_elim 17 19.
23. 1, 10, 11, 12, 19 ⊢ x ∈ B, from_indicator_app_is_one 18 22 21.
24. 1, 10, 11, 12 ⊢ x ∈ A → x ∈ B, subj_intro 23.
25. 25 ⊢ x ∈ B, hypo.
26. 11, 25 ⊢ app (χ B X) x = {∅}, indicator_app_is_one 18 25.
27. 1, 10, 11, 12, 25 ⊢ app (χ A X) x = {∅},
  eq_subst_rev 16 26, P t ↔ app t x = {∅}.
28. 11, 25 ⊢ x ∈ X, incl_elim 18 25.
29. 1, 10, 11, 12, 25 ⊢ x ∈ A, from_indicator_app_is_one 17 28 27.
30. 1, 10, 11, 12 ⊢ x ∈ B → x ∈ A, subj_intro 29.
31. 1, 10, 11, 12 ⊢ x ∈ A ↔ x ∈ B, bij_intro 24 30.
32. 1, 10, 11, 12 ⊢ ∀x. x ∈ A ↔ x ∈ B, uq_intro 31.
33. 1, 10, 11, 12 ⊢ A = B, ext 32.
34. 1 ⊢ A ∈ power X → B ∈ power X → app φ A = app φ B → A = B,
  subj_intro_iii 33.
35. 1 ⊢ ∀B. A ∈ power X → B ∈ power X →
  app φ A = app φ B → A = B, uq_intro 34.
36. 1 ⊢ ∀A. ∀B. A ∈ power X → B ∈ power X →
  app φ A = app φ B → A = B, uq_intro 35.
37. 1 ⊢ inj φ (power X) (Map X {∅, {∅}}), inj_intro 9 36.

let A = inv_img f {{∅}}.
38. 38 ⊢ f ∈ Map X {∅, {∅}}, hypo.
39. 38 ⊢ map f X {∅, {∅}}, Map_elim 38.
40. 38 ⊢ function f ∧ dom f = X ∧ rng f ⊆ {∅, {∅}}, map_unfold 39.
41. 38 ⊢ dom f = X, conj_elimlr 40.
42. 42 ⊢ x ∈ X, hypo.
43. 38, 42 ⊢ app f x ∈ {∅, {∅}}, map_app_in_cod 39 42.
44. 38, 42 ⊢ app f x ∈ {∅} ∨ app f x ∈ {{∅}}, union_elim 43.

45. 45 ⊢ app f x ∈ {∅}, hypo.
46. 45 ⊢ app f x = ∅, sg_elim empty_set_is_set 45.
47. 45 ⊢ ∅ = app f x, eq_symm 46.
48. 38, 42, 45 ⊢ (x, ∅) ∈ f, map_app_elim 39 42 47.
49. ⊢ A ⊆ dom f, inv_img_incl_in_dom.
50. 38 ⊢ A ⊆ X, eq_subst 41 49, P t ↔ A ⊆ t.
51. 51 ⊢ x ∈ A, hypo.
52. 51 ⊢ ∃y. y ∈ {{∅}} ∧ (x, y) ∈ f, inv_img_elim 51.
53. 53 ⊢ y ∈ {{∅}} ∧ (x, y) ∈ f, hypo.
54. 53 ⊢ y ∈ {{∅}}, conj_eliml 53.
55. 53 ⊢ (x, y) ∈ f, conj_elimr 53.
56. 38 ⊢ function f, conj_elimll 40.
57. 38, 42, 45, 53 ⊢ y = ∅, fn_unique_value 56 55 48.
58. ⊢ set {∅}, set_sg empty_set_is_set.
59. 53 ⊢ y = {∅}, sg_elim 58 54.
60. 38, 42, 45, 53 ⊢ ∅ = {∅}, eq_trans_ll 57 59.
61. 38, 42, 45, 53 ⊢ ⊥, neg_elim zero_neq_one 60.
62. 38, 42, 45, 51 ⊢ ⊥, ex_elim 52 61.
63. 38, 42, 45 ⊢ ¬x ∈ A, neg_intro 62.
64. 38, 42, 45 ⊢ x ∈ X \ A, diff_intro 42 63.
65. 38, 42, 45 ⊢ app (χ A X) x = ∅, indicator_app_is_zero 50 64.
66. 38, 42, 45 ⊢ ∅ = app (χ A X) x, eq_symm 65.
67. 38, 42, 45 ⊢ app f x = app (χ A X) x, eq_trans 46 66.

68. 68 ⊢ app f x ∈ {{∅}}, hypo.
69. 68 ⊢ app f x = {∅}, sg_elim 58 68.
70. 68 ⊢ {∅} = app f x, eq_symm 69.
71. 38, 42, 68 ⊢ (x, {∅}) ∈ f, map_app_elim 39 42 70.
72. ⊢ {∅} = {∅}, eq_refl.
73. ⊢ {∅} ∈ {{∅}}, sg_intro 58 72.
74. 38, 42, 68 ⊢ x ∈ A, inv_img_intro 73 71.
75. 38, 42, 68 ⊢ app (χ A X) x = {∅}, indicator_app_is_one 50 74.
76. 38, 42, 68 ⊢ {∅} = app (χ A X) x, eq_symm 75.
77. 38, 42, 68 ⊢ app f x = app (χ A X) x, eq_trans 69 76.

78. 38, 42 ⊢ app f x = app (χ A X) x, disj_elim 44 67 77.
79. 38 ⊢ x ∈ X → app f x = app (χ A X) x, subj_intro 78.
80. 38 ⊢ ∀x. x ∈ X → app f x = app (χ A X) x, uq_intro 79.
81. 38 ⊢ map (χ A X) X {∅, {∅}}, indicator_is_map 50.
82. 38 ⊢ f = χ A X, map_extensionality 39 81 80.
83. 1, 38 ⊢ set A, subset 50 1.
84. 1, 38 ⊢ A ∈ power X, power_intro 83 50.
85. 1, 38 ⊢ app φ A = χ A X, map_from_term_app 8 7 84.
86. 1, 38 ⊢ χ A X = app φ A, eq_symm 85.
87. 1, 38 ⊢ f = app φ A, eq_trans 82 86.
88. 1, 38 ⊢ (A, f) ∈ φ, map_app_elim 9 84 87.
89. 1, 38 ⊢ f ∈ rng φ, rng_intro 88.
90. 1 ⊢ f ∈ Map X {∅, {∅}} → f ∈ rng φ, subj_intro 89.
91. 1 ⊢ ∀f. f ∈ Map X {∅, {∅}} → f ∈ rng φ, uq_intro 90.
92. 1 ⊢ Map X {∅, {∅}} ⊆ rng φ, incl_intro 91.
93. 1 ⊢ sur φ (power X) (Map X {∅, {∅}}), sur_intro 9 92.

94. 1 ⊢ bij φ (power X) (Map X {∅, {∅}}), bij_from_inj_sur 37 93.
95. 1 ⊢ ∃g. bij g (power X) (Map X {∅, {∅}}), ex_intro 94.
96. 1 ⊢ num_eq (power X) (Map X {∅, {∅}}), num_eq_intro 95.
power_equinum_indicators. ⊢ set X →
  num_eq (power X) (Map X {∅, {∅}}), subj_intro 96.
end

begin
let i = {t | ∃x. x ∈ X ∧ t = (x, {x})}.
01. ⊢ i = i, eq_refl.
02. 2 ⊢ x ∈ X, hypo.
03. 2 ⊢ {x} ⊆ X, sg_incl_in 2.
04. 2 ⊢ set x, set_intro 2.
05. 2 ⊢ set {x}, set_sg 4.
06. 2 ⊢ {x} ∈ power X, power_intro 5 3.
07. ⊢ x ∈ X → {x} ∈ power X, subj_intro 6.
08. ⊢ ∀x. x ∈ X → {x} ∈ power X, uq_intro 7.
09. ⊢ map i X (power X), map_from_term 1 8.
10. 10 ⊢ a ∈ X, hypo.
11. 11 ⊢ b ∈ X, hypo.
12. 12 ⊢ app i a = app i b, hypo.
13. 10 ⊢ app i a = {a}, map_from_term_app 1 8 10.
14. 11 ⊢ app i b = {b}, map_from_term_app 1 8 11.
15. 11, 12 ⊢ app i a = {b}, eq_trans 12 14.
16. 10, 11, 12 ⊢ {a} = {b}, eq_trans_ll 13 15.
17. 10 ⊢ set a, set_intro 10.
18. 11 ⊢ set b, set_intro 11.
19. 10, 11, 12 ⊢ a = b, sg_is_inj 17 18 16.
20. ⊢ a ∈ X → b ∈ X → app i a = app i b → a = b, subj_intro_iii 19.
21. ⊢ ∀b. a ∈ X → b ∈ X → app i a = app i b → a = b, uq_intro 20.
22. ⊢ ∀a. ∀b. a ∈ X → b ∈ X → app i a = app i b → a = b, uq_intro 21.
23. ⊢ inj i X (power X), inj_intro 9 22.
24. ⊢ ∃g. inj g X (power X), ex_intro 23.

let D = {x | x ∈ X ∧ ¬x ∈ app f x}.
25. 25 ⊢ set X, hypo.
26. 26 ⊢ ∃f. sur f X (power X), hypo.
27. 27 ⊢ sur f X (power X), hypo.
28. ⊢ D ⊆ X, sep_is_subclass.
29. 25 ⊢ set D, subset 28 25.
30. 25 ⊢ D ∈ power X, power_intro 29 28.
31. 27 ⊢ rng f = power X, sur_elim 27.
32. 25, 27 ⊢ D ∈ rng f, eq_subst_rev 31 30, P t ↔ D ∈ t.
33. 27 ⊢ map f X (power X), sur_is_map 27.
34. 25, 27 ⊢ ∃x. x ∈ X ∧ D = app f x, map_rng_elim 33 32.
35. 35 ⊢ x ∈ X ∧ D = app f x, hypo.
36. 35 ⊢ x ∈ X, conj_eliml 35.
37. 35 ⊢ D = app f x, conj_elimr 35.
38. ⊢ x ∈ D ↔ x ∈ D, equi_refl.
39. 35 ⊢ x ∈ app f x ↔ x ∈ D, eq_subst 37 38, P t ↔ (x ∈ t ↔ x ∈ D).
40. 40 ⊢ x ∈ D, hypo.
41. 40 ⊢ x ∈ X ∧ ¬x ∈ app f x, comp_elim 40.
42. 40 ⊢ ¬x ∈ app f x, conj_elimr 41.
43. ⊢ x ∈ D → ¬x ∈ app f x, subj_intro 42.
44. 44 ⊢ ¬x ∈ app f x, hypo.
45. 35, 44  ⊢ x ∈ X ∧ ¬x ∈ app f x, conj_intro 36 44.
46. 35 ⊢ set x, set_intro 36.
47. 35, 44 ⊢ x ∈ D, comp_intro 46 45.
48. 35 ⊢ ¬x ∈ app f x → x ∈ D, subj_intro 47.
49. 35 ⊢ x ∈ D ↔ ¬x ∈ app f x, bij_intro 43 48.
50. 35 ⊢ x ∈ app f x ↔ ¬x ∈ app f x, equi_trans 39 49.
51. 35 ⊢ ⊥, diag_contra 50.
52. 25, 27 ⊢ ⊥, ex_elim 34 51.
53. 25, 26 ⊢ ⊥, ex_elim 26 52.
54. 25 ⊢ ¬∃f. sur f X (power X), neg_intro 53.

55. ⊢ num_le X (power X), num_le_fold 24.
56. 25 ⊢ num_lt X (power X), num_lt_intro 55 54.
Cantor's_theorem. ⊢ set X → num_lt X (power X), subj_intro 56.
end

begin
let h S = X \ img g (Y \ img f S).
let Gh = {t | ∃S. S ∈ power X ∧ t = (S, h S)}.
01. 1 ⊢ set X, hypo.
02. 2 ⊢ rng g ⊆ X, hypo.
03. ⊢ Gh = Gh, eq_refl.

04. 4 ⊢ S ∈ power X, hypo.
05. ⊢ h S ⊆ X, diff_incl.
06. 1 ⊢ set (h S), subset 5 1.
07. 1 ⊢ h S ∈ power X, power_intro 6 5.
08. 1, 4 ⊢ h S ∈ power X, wk 7.
09. 1 ⊢ S ∈ power X → h S ∈ power X, subj_intro 8.
10. 1 ⊢ ∀S. S ∈ power X → h S ∈ power X, uq_intro 9.

11. 11 ⊢ T ⊆ X, hypo.
12. 12 ⊢ S ⊆ T, hypo.
13. 12 ⊢ img f S ⊆ img f T, img_incl 12.
14. 12 ⊢ Y \ (img f T) ⊆ Y \ (img f S), incl_contraposition 13.
15. 12 ⊢ img g (Y \ (img f T)) ⊆ img g (Y \ (img f S)), img_incl 14.
16. 12 ⊢ h S ⊆ h T, incl_contraposition 15.

17. 11, 12 ⊢ S ⊆ X, incl_trans 12 11.
18. 1, 11, 12 ⊢ set S, subset 17 1.
19. 1, 11 ⊢ set T, subset 11 1.
20. 1, 11, 12 ⊢ S ∈ power X, power_intro 18 17.
21. 1, 11 ⊢ T ∈ power X, power_intro 19 11.
22. 1, 11, 12 ⊢ app Gh S = h S, map_from_term_app 3 10 20.
23. 1, 11 ⊢ app Gh T = h T, map_from_term_app 3 10 21.

24. 1, 11, 12 ⊢ app Gh S ⊆ h T,
  eq_subst_rev 22 16, P t ↔ t ⊆ h T.
25. 1, 11, 12 ⊢ app Gh S ⊆ app Gh T,
  eq_subst_rev 23 24, P t ↔ app Gh S ⊆ t.
26. 1 ⊢ T ⊆ X → S ⊆ T →
  app Gh S ⊆ app Gh T, subj_intro_ii 25.
27. 1 ⊢ ∀T. T ⊆ X → S ⊆ T →
  app Gh S ⊆ app Gh T, uq_intro 26.
28. 1 ⊢ ∀S. ∀T. T ⊆ X → S ⊆ T →
  app Gh S ⊆ app Gh T, uq_intro 27.
29. 1 ⊢ map Gh (power X) (power X), map_from_term 3 10.
30. 1 ⊢ ∃A. A ⊆ X ∧ app Gh A = A ∧
  (∀U. U ⊆ X → app Gh U = U → A ⊆ U),
  incl_Knaster_Tarski_least 1 29 28.

31. 31 ⊢ A ⊆ X ∧ app Gh A = A ∧
  (∀U. U ⊆ X → app Gh U = U → A ⊆ U), hypo.
32. 31 ⊢ A ⊆ X, conj_elimll 31.
33. 31 ⊢ app Gh A = A, conj_elimlr 31.
34. 1, 31 ⊢ set A, subset 32 1.
35. 1, 31 ⊢ A ∈ power X, power_intro 34 32.
36. 1, 31 ⊢ app Gh A = h A, map_from_term_app 3 10 35.
37. 1, 31 ⊢ h A = A, eq_trans_ll 36 33.
38. ⊢ img g (Y \ img f A) ⊆ rng g, img_incl_in_rng.
39. 2 ⊢ img g (Y \ img f A) ⊆ X, incl_trans 38 2.
40. 2 ⊢ X \ h A = img g (Y \ img f A), diff_is_involution 39.
41. 1, 2, 31 ⊢ X \ A = img g (Y \ img f A),
  eq_subst 37 40, P t ↔ X \ t = img g (Y \ img f A).
42. 1, 2, 31 ⊢ img g (Y \ img f A) = X \ A, eq_symm 41.
43. ⊢ img f A = img f A, eq_refl.
44. 31 ⊢ A ⊆ X ∧ img f A = img f A, conj_intro 32 43.
45. 1, 2, 31 ⊢ A ⊆ X ∧ img f A = img f A ∧
  img g (Y \ img f A) = X \ A, conj_intro 44 42.
46. 1, 2, 31 ⊢ ∃B. A ⊆ X ∧ img f A = B ∧
  img g (Y \ B) = X \ A, ex_intro 45.
47. 1, 2, 31 ⊢ ∃A. ∃B. A ⊆ X ∧ img f A = B ∧
  img g (Y \ B) = X \ A, ex_intro 46.
48. 1, 2 ⊢ ∃A. ∃B. A ⊆ X ∧ img f A = B ∧
  img g (Y \ B) = X \ A, ex_elim 30 47.
Banach_decomposition_theorem. ⊢ set X → rng g ⊆ X →
  ∃A. ∃B. A ⊆ X ∧ img f A = B ∧ img g (Y \ B) = X \ A,
  subj_intro_ii 48.
end

01. 1 ⊢ set X, hypo.
02. 2 ⊢ num_le X Y, hypo.
03. 3 ⊢ num_le Y X, hypo.
04. 2 ⊢ ∃f. inj f X Y, num_le_unfold 2.
05. 3 ⊢ ∃g. inj g Y X, num_le_unfold 3.
06. 6 ⊢ inj f X Y, hypo.
07. 7 ⊢ inj g Y X, hypo.
08. 6 ⊢ map f X Y, inj_is_map 6.
09. 7 ⊢ map g Y X, inj_is_map 7.
10. 7 ⊢ rng g ⊆ X, map_rng 9.
11. 1, 7 ⊢ ∃A. ∃B. A ⊆ X ∧ img f A = B ∧ img g (Y \ B) = X \ A,
  Banach_decomposition_theorem 1 10.
12. 12 ⊢ ∃B. A ⊆ X ∧ img f A = B ∧ img g (Y \ B) = X \ A, hypo.
13. 13 ⊢ A ⊆ X ∧ img f A = B ∧ img g (Y \ B) = X \ A, hypo.
14. 13 ⊢ A ⊆ X, conj_elimll 13.
15. 13 ⊢ img f A = B, conj_elimlr 13.
16. 13 ⊢ img g (Y \ B) = X \ A, conj_elimr 13.
17. 6, 13 ⊢ inj (restr f A) A Y, restr_is_inj 6 14.
18. 6, 13 ⊢ map (restr f A) A Y, map_restr 8 14.
19. ⊢ img f A = img (restr f A) A, restr_img_self.
20. 6, 13 ⊢ img (restr f A) A = rng (restr f A),
  map_img_of_dom_is_rng 18.
21. 6, 13 ⊢ img f A = rng (restr f A), eq_trans 19 20.
22. 6, 13 ⊢ rng (restr f A) = B, eq_trans_ll 21 15.
23. 6, 13 ⊢ sur (restr f A) A B, rng_restr_is_sur 18 22.
24. 6, 13 ⊢ rng (restr f A) ⊆ B, incl_from_eq 22.
25. 6, 13 ⊢ inj (restr f A) A B, rng_restr_is_inj 17 24.
26. 6, 13 ⊢ bij (restr f A) A B, bij_from_inj_sur 25 23.
27. ⊢ Y \ B ⊆ Y, diff_incl.
28. 7 ⊢ inj (restr g (Y \ B)) (Y \ B) X, restr_is_inj 7 27.
29. 7 ⊢ map (restr g (Y \ B)) (Y \ B) X, inj_is_map 28.
30. ⊢ img g (Y \ B) = img (restr g (Y \ B)) (Y \ B), restr_img_self.
31. 13 ⊢ img (restr g (Y \ B)) (Y \ B) = X \ A, eq_trans_ll 30 16.
32. 7 ⊢ img (restr g (Y \ B)) (Y \ B) = rng (restr g (Y \ B)),
  map_img_of_dom_is_rng 29.
33. 7, 13 ⊢ rng (restr g (Y \ B)) = X \ A, eq_trans_ll 32 31.
34. 7, 13 ⊢ rng (restr g (Y \ B)) ⊆ X \ A, incl_from_eq 33.
35. 7, 13 ⊢ inj (restr g (Y \ B)) (Y \ B) (X \ A),
  rng_restr_is_inj 28 34.
36. 7, 13 ⊢ sur (restr g (Y \ B)) (Y \ B) (X \ A),
  rng_restr_is_sur 29 33.
37. 7, 13 ⊢ bij (restr g (Y \ B)) (Y \ B) (X \ A),
  bij_from_inj_sur 35 36.
38. 7, 13 ⊢ bij (inv (restr g (Y \ B))) (X \ A) (Y \ B),
  inv_of_bij_is_bij 37.
39. ⊢ A ∩ (X \ A) = ∅, intersection_rel_compl.
40. ⊢ B ∩ (Y \ B) = ∅, intersection_rel_compl.
41. 6, 7, 13 ⊢ bij (restr f A ∪ inv (restr g (Y \ B)))
  (A ∪ (X \ A)) (B ∪ (Y \ B)), bij_union 26 38 39 40.

42. ⊢ img f A ⊆ rng f, img_incl_in_rng.
43. 6 ⊢ rng f ⊆ Y, map_rng 8.
44. 6 ⊢ img f A ⊆ Y, incl_trans 42 43.
45. 6, 13 ⊢ B ⊆ Y, eq_subst 15 44, P t ↔ t ⊆ Y.
46. 13 ⊢ (X \ A) ∪ A = X, diff_union_subclass 14.
47. 6, 13 ⊢ (Y \ B) ∪ B = Y, diff_union_subclass 45.
48. ⊢ A ∪ (X \ A) = (X \ A) ∪ A, union_comm.
49. ⊢ B ∪ (Y \ B) = (Y \ B) ∪ B, union_comm.
50. 13 ⊢ A ∪ (X \ A) = X, eq_trans 48 46.
51. 6, 13 ⊢ B ∪ (Y \ B) = Y, eq_trans 49 47.
52. 6, 7, 13 ⊢
  bij (restr f A ∪ inv (restr g (Y \ B))) X (B ∪ (Y \ B)),
  eq_subst 50 41,
  P t ↔ bij (restr f A ∪ inv (restr g (Y \ B))) t (B ∪ (Y \ B)).
53. 6, 7, 13 ⊢
  bij (restr f A ∪ inv (restr g (Y \ B))) X Y, eq_subst 51 52,
  P t ↔ bij (restr f A ∪ inv (restr g (Y \ B))) X t.

54. 6, 7, 13 ⊢ ∃h. bij h X Y, ex_intro 53.
55. 6, 7, 13 ⊢ num_eq X Y, num_eq_intro 54.
56. 6, 7, 12 ⊢ num_eq X Y, ex_elim 12 55.
57. 1, 6, 7 ⊢ num_eq X Y, ex_elim 11 56.
58. 1, 3, 6 ⊢ num_eq X Y, ex_elim 5 57.
59. 1, 2, 3 ⊢ num_eq X Y, ex_elim 4 58.
Cantor_Bernstein_theorem. ⊢ set X → num_le X Y →
  num_le Y X → num_eq X Y, subj_intro_iii 59.

(*/note num_eq_equi
Two sets X, Y are called <i>equinumerous</i>, written |X| = |Y|, if
there exists a [[bij_equi|bijection]] from X to Y. *)

(*/note num_le_equi
A set X is called <i>not greater than</i> Y, written |X| ≤ |Y|, if
there exists an [[inj_equi|injection]] from X to Y. *)

(*/note num_lt_equi
A set X is called <i>strictly smaller than</i> Y, written
|X| &lt; |Y|, if X is [[num_le_equi|not greater]] than Y and
there is no [[sur_equi|surjection]] from X to Y. *)

(*/note Map_eq The set of [[map_equi|mappings]] from X to Y. *)

(*/note indicator_eq
The <i>indicator function</i> of A, defined as<br>
\_\_χ<sub>A</sub>: X → {0, 1}, χ<sub>A</sub> x := 1 if x ∈ A else 0. *)

(*/note power_equinum_indicators
This theorem states that the [[power_eq|power set]] of a set X is
[[num_eq_equi|equinumerous]] to set of [[map_equi|maps]]
from X to {0,\_1}.<br>
<br>
<b>Proof sketch</b><br>
[[num_eq_equi|Equinumerousity]] of two sets means that there
is a bijection between them. We have the canonical bijection<br>
\_\_φ: power X → Map X {0, 1}, φ A := χ<sub>A</sub>,<br>
where χ<sub>A</sub> is the [[indicator_eq|indicator function]] of A.
First we need to show that φ is injective. So let A, B be two arbritary
sets in the domain. Assume φ\_A = φ\_B. By definition of φ this means
χ<sub>A</sub> = χ<sub>B</sub>. Let x\_∈\_A. Then χ<sub>A</sub>\_=\_1,
thus χ<sub>B</sub>\_=\_1, and therefore x\_∈\_B. In the same way,
x\_∈\_A is derived from x\_∈\_B. Thus A = B by [[ext|extensionality]].
Now we need to show that φ is surjective. So let f be an arbritary
element in the codomain. We need to find an A with φ\_A = f.
Let A := f<sup>&minus;1</sup>{1}, the "one-fiber" of\_f.
So we need to show χ<sub>A</sub>\_x = f\_x for an arbritary x\_∈\_X,
then χ<sub>A</sub> = f holds by [[map_extensionality|function extensionality]].
There are only two cases for the value of\_f. In the case f\_x = 1, it
holds that x\_∈\_A, since A has just been defined this way. So
χ<sub>A</sub>\_x = 1, thus χ<sub>A</sub>\_x = f\_x, as desired.
In the case f\_x = 0, it holds that x\_∈\_X\_\\_A, for the same reason.
So χ<sub>A</sub>\_x = 0, thus χ<sub>A</sub>\_x = f\_x,
as desired. q.e.d. *)

(*/note Cantor's_theorem
This theorem states that any [[set_equi|set]] is
[[num_lt_equi|strictly less numerous]] than its power set.<br>
<br>
<b>Proof sketch</b><br>
First, it must be shown that an [[inj_equi|injection]] i: X →
power\_X exists. This is easily witnessed by i\_x := {x}, since we have
[[sg_is_inj]]. Now it must be shown that no [[sur_equi|surjection]]
f: X → power\_X exists. So let f be such a surjection; we need to find
a contradiction. Consider the "diagonal" set<br>
\_\_D = {x ∈ X | x ∉ f x}.<br>
Because D ⊆ X, we have D ∈ power\_X. Furthermore, because\_f is
surjective, we have D\_∈\_rng\_f. So there is an x\_∈\_X with
D = f\_x. Since x\_∈\_X, we obtain the equivalence
x\_∈\_D\_↔ x\_∉\_f\_x
directly from the Definition of\_D. Thus<br>
\_\_x ∈ f x ↔ x ∉ f x,<br>
but this is a contradiction, as shown in [[diag_contra]]. q.e.d.
*)

(*/note Banach_decomposition_theorem
Given sets X, Y and two functions f:\_X\_→\_Y and g:\_Y\_→\_X. Then
there exists a decomposition of X into two disjoint subsets A and X\A,
and a decomposition of Y into two disjoint subsets B and Y\B,
such that f[A]\_= B and g[Y\B]\_= X\A.<br>
<br>
<b>Proof idea</b><br>
The idea is to reduce the problem to finding a suitable function on the
[[power_eq|power set]] of X, to which the
[[incl_Knaster_Tarski_least|Knaster-Tarski fixed-point theorem]]
is applied. The second equation takes on the role of the transformed
fixed-point equation, while the first equation holds by definition.<br>
<br>
<b>Proof sketch</b><br>
We consider the [[power_eq|power set]] P(X), which forms a complete
lattice under the [[incl_equi|inclusion]] relation ⊆. We define the
function<br>
\_\_h: P(X) → P(X), h(S) := X\g[Y\f[S]].<br>
A fixed point of this function is a set A ⊆ X for which h(A) = A.
Unfolding h, this equality is X\g[Y\f[A]]\_= A, which, by taking the
complement of both sides, is precisely g[Y\f[A]] = X\A, the statement
to be proven. To apply the Knaster-Tarski theorem, we must show that\_h
is monotone (order-preserving), i.e., for S\_⊆\_T,
it follows that h(S)\_⊆\_h(T). Let S,\_T ⊆ X with S\_⊆\_T. Then<br>
\_\_f[S] ⊆ f[T] (the [[img_eq|image]] under a function
preserves inclusion),<br>
\_\_Y\f[T] ⊆ Y\f[S] (taking the [[diff_eq|complement]]
reverses inclusion),<br>
\_\_g[Y\f[T]] ⊆ g[Y\f[S]] (the image under a
function preserves inclusion),<br>
\_\_X\g[Y\f[S]] ⊆ X\g[Y\f[T]] (taking the
complement again reverses the inclusion).<br>
By definition, this is equivalent to h(S)\_⊆\_h(T).
Thus, the function h is monotone. Since h is a monotone function on the
complete lattice (P(X),\_⊆), the Knaster-Tarski fixed-point theorem
guarantees the existence of (at least) one fixed point A ∈ P(X) such
that h(A) = A. As shown, this is equivalent to the statement
g[Y\B] = X\A with B := f[A]. q.e.d. *)

(*/note Cantor_Bernstein_theorem
This theorem states that [[num_le_equi|not greater than]] behaves
antisymmetric, that is, |X|\_=\_|Y| follows from |X|\_≤\_|Y| and
|Y|\_≤\_|X|. In words, X and Y are [[num_eq_equi|equinumerous]]
if, on the one hand, X is not greater than Y and, on the other hand, Y
is not greater than X. This means that a [[bij_equi|bijection]] from
X to Y exists if there is an [[inj_equi|injection]] from X to Y on the
one hand and an injection from Y to X on the other.<br>
<br>
<b>Proof idea</b><br>
According to the premises, there is an injection from X to Y and an
injection from Y to X. Using the [[Banach_decomposition_theorem|Banach
decomposition theorem]], X and Y can now be decomposed into disjoint
subsets such that the injections take the form of bijections when
restricted to these subsets. For the latter, we consider the inverse
mapping so that both go in the same direction. These two bijections
can now be joined together to form a bijection from X to\_Y.<br>
<br>
<b>Proof sketch</b><br>
According to the premises, we have an injection f:\_X →\_Y and an
injection g:\_Y\_→\_X. Furthermore, according to the
[[Banach_decomposition_theorem|Banach decomposition theorem]], there
exist A\_⊆\_X and B\_⊆\_Y such that f[A] = B and g[Y\B] = X\A.
Therefore, the [[restr_eq|restrictions]] f|<sub>A</sub>: A → B and
g|<sub>Y\B</sub>: Y\B → X\A are bijective. Consequently, the inverse of
g|<sub>Y\B</sub> is also bijective. The two can now be combined via
[[bij_union]] to form a bijection X\_→\_Y, since both X\_= A\_∪\_(X\A)
and Y\_= B\_∪\_(Y\B) are unions of disjoint sets. q.e.d. *)

